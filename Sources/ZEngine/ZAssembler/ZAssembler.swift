/// Z-Machine Assembler - Converts ZAP assembly language to Z-Machine bytecode
import Foundation

/// Main Z-Machine Assembler class that converts ZAP assembly to bytecode
///
/// The Z-Machine Assembler takes ZAP (Z-Machine Assembly Program) source code
/// generated by the ZIL compiler and converts it into executable Z-Machine
/// bytecode that can be run on Z-Machine interpreters.
///
/// ## Key Responsibilities
/// - Parse ZAP assembly directives and instructions
/// - Resolve symbolic addresses and labels
/// - Encode instructions in proper Z-Machine bytecode format
/// - Generate proper memory layout and headers for target version
/// - Produce final story files (.z3, .z4, .z5, .z6, .z8)
///
/// ## Usage Example
/// ```swift
/// let assembler = ZAssembler(version: .v5)
/// let bytecode = try assembler.assemble(zapSource)
/// try bytecode.write(to: URL(fileURLWithPath: "game.z5"))
/// ```
public class ZAssembler {

    /// The target Z-Machine version for this assembly
    public let version: ZMachineVersion

    /// Current assembly state and symbol tracking
    private var state = AssemblyState()

    /// Instruction encoder for generating bytecode
    private var encoder: InstructionEncoder

    /// Memory layout manager
    private var memoryLayout: MemoryLayoutManager

    /// Creates a new Z-Machine assembler for the specified version
    ///
    /// - Parameter version: Target Z-Machine version (defaults to v5)
    public init(version: ZMachineVersion = .v5) {
        self.version = version
        self.encoder = InstructionEncoder(version: version)
        self.memoryLayout = MemoryLayoutManager(version: version)
    }

    /// Assembles ZAP source code into Z-Machine bytecode
    ///
    /// Takes ZAP assembly source and produces a complete Z-Machine story file
    /// with proper headers, memory layout, and encoded instructions.
    ///
    /// - Parameter zapSource: The ZAP assembly source code as a string
    /// - Returns: Complete Z-Machine bytecode as Data
    /// - Throws: AssemblyError for any assembly failures
    public func assemble(_ zapSource: String) throws -> Data {
        // Reset state for new assembly
        state = AssemblyState()
        encoder = InstructionEncoder(version: version)
        memoryLayout = MemoryLayoutManager(version: version)

        // Parse the ZAP source into assembly statements
        let parser = ZAPParser()
        let statements = try parser.parse(zapSource)

        // Two-pass assembly process
        try performFirstPass(statements)
        try performSecondPass(statements)

        // Generate final bytecode with proper memory layout
        return try generateBytecode()
    }

    /// Assembles ZAP source from a file
    ///
    /// Convenience method for assembling directly from ZAP files.
    ///
    /// - Parameter zapFile: URL of the ZAP source file
    /// - Returns: Complete Z-Machine bytecode as Data
    /// - Throws: AssemblyError or file I/O errors
    public func assemble(from zapFile: URL) throws -> Data {
        let zapSource = try String(contentsOf: zapFile, encoding: .utf8)
        return try assemble(zapSource)
    }

    // MARK: - Assembly Passes

    /// First pass: collect symbols, labels, and calculate sizes
    private func performFirstPass(_ statements: [ZAPStatement]) throws {
        var currentAddress: UInt32 = 0

        for statement in statements {
            switch statement {
            case .directive(let directive, let location):
                currentAddress = try processDirectiveFirstPass(directive, at: currentAddress, location: location)

            case .instruction(let instruction, let location):
                // Calculate instruction size and add to current address
                let size = try encoder.calculateInstructionSize(instruction, at: currentAddress)
                state.addSymbol(instruction.label, address: currentAddress, location: location)
                currentAddress += size

            case .objectProperty(let property, let location):
                // Object properties don't affect address calculation but need object context
                guard state.currentObject != nil else {
                    throw AssemblyError.invalidInstruction("Object property '\(property.name)' outside object block", location: location)
                }

            case .label(let name, let location):
                state.addSymbol(name, address: currentAddress, location: location)

            case .comment:
                // Comments don't affect assembly
                break
            }
        }
    }

    /// Second pass: generate actual bytecode with resolved addresses
    private func performSecondPass(_ statements: [ZAPStatement]) throws {
        for statement in statements {
            switch statement {
            case .directive(let directive, let location):
                try processDirectiveSecondPass(directive, location: location)

            case .instruction(let instruction, let location):
                let currentAddress = memoryLayout.getCurrentAddress()
                let bytecode = try encoder.encodeInstruction(instruction, symbolTable: state.symbolTable, location: location, currentAddress: currentAddress)
                memoryLayout.addCode(bytecode)

            case .objectProperty(let property, let location):
                // Process object property assignment
                guard let objectName = state.currentObject else {
                    throw AssemblyError.invalidInstruction("Object property '\(property.name)' outside object block", location: location)
                }
                try memoryLayout.addObjectProperty(objectName: objectName, propertyName: property.name, value: property.value, symbolTable: state.symbolTable, location: location)

            case .label, .comment:
                // Already processed in first pass
                break
            }
        }
    }

    /// Generate final bytecode with headers and proper memory layout
    private func generateBytecode() throws -> Data {
        return try memoryLayout.generateStoryFile()
    }

    // MARK: - Directive Processing

    private func processDirectiveFirstPass(_ directive: ZAPDirective, at address: UInt32, location: SourceLocation) throws -> UInt32 {
        switch directive.name.uppercased() {
        case "ZVERSION":
            // Version directive - validate version matches
            if let versionArg = directive.arguments.first?.asNumber,
               versionArg != Int16(version.rawValue) {
                throw AssemblyError.versionMismatch(
                    instruction: "ZVERSION \(versionArg)",
                    version: Int(version.rawValue),
                    location: location
                )
            }
            return address

        case "CONSTANT":
            guard directive.arguments.count == 2 else {
                throw AssemblyError.invalidOperand(instruction: "CONSTANT", operand: "requires 2 arguments", location: location)
            }
            if let name = directive.arguments[0].asAtom {
                state.addConstant(name, value: directive.arguments[1])
            }
            return address

        case "GLOBAL":
            guard let name = directive.arguments.first?.asAtom else {
                throw AssemblyError.invalidOperand(instruction: "GLOBAL", operand: "requires symbol name", location: location)
            }
            let globalAddress = memoryLayout.allocateGlobal(name)
            state.addSymbol(name, address: globalAddress, location: location)
            return address

        case "FUNCT":
            guard let name = directive.arguments.first?.asAtom else {
                throw AssemblyError.invalidOperand(instruction: "FUNCT", operand: "requires function name", location: location)
            }
            state.addSymbol(name, address: address, location: location)
            state.currentFunction = name

            // Set MAIN function as the start routine for the story file
            if name.uppercased() == "MAIN" {
                memoryLayout.setStartRoutine(address: address)
            }

            return address

        case "ENDI":
            state.currentFunction = nil
            return address

        case "STRING":
            guard directive.arguments.count >= 2,
                  let stringId = directive.arguments[0].asAtom,
                  let content = directive.arguments[1].asString else {
                throw AssemblyError.invalidOperand(instruction: "STRING", operand: "requires ID and content", location: location)
            }
            let stringAddress = memoryLayout.addString(stringId, content: content)
            state.addSymbol(stringId, address: stringAddress, location: location)
            return address

        case "OBJECT":
            guard let name = directive.arguments.first?.asAtom else {
                throw AssemblyError.invalidOperand(instruction: "OBJECT", operand: "requires object name", location: location)
            }
            let objectAddress = memoryLayout.allocateObject(name)
            state.addSymbol(name, address: objectAddress, location: location)
            state.currentObject = name  // Start object context
            return address

        case "PROPERTY":
            guard let name = directive.arguments.first?.asAtom else {
                throw AssemblyError.invalidOperand(instruction: "PROPERTY", operand: "requires property name", location: location)
            }
            memoryLayout.addProperty(name)
            return address

        case "ENDOBJECT":
            state.currentObject = nil  // End object context
            return address

        case "BYTE":
            guard directive.arguments.count >= 1 else {
                throw AssemblyError.invalidOperand(instruction: "BYTE", operand: "requires at least 1 argument", location: location)
            }
            // Each byte takes 1 byte of memory
            return address + UInt32(directive.arguments.count)

        case "WORD":
            guard directive.arguments.count >= 1 else {
                throw AssemblyError.invalidOperand(instruction: "WORD", operand: "requires at least 1 argument", location: location)
            }
            // Each word takes 2 bytes of memory
            return address + UInt32(directive.arguments.count * 2)

        case "STR":
            guard directive.arguments.count >= 1,
                  let content = directive.arguments[0].asString else {
                throw AssemblyError.invalidOperand(instruction: "STR", operand: "requires string content", location: location)
            }

            // Calculate encoded string length for memory allocation
            let encodedLength = calculateEncodedStringLength(content)
            return address + encodedLength

        case "GVAR":
            guard directive.arguments.count >= 1,
                  let nameAndValue = directive.arguments[0].asAtom else {
                throw AssemblyError.invalidOperand(instruction: "GVAR", operand: "requires variable definition", location: location)
            }

            // Parse GVAR format: VARIABLE=VALUE or just VARIABLE
            let components = nameAndValue.split(separator: "=", maxSplits: 1)
            let varName = String(components[0])
            let varValue = components.count > 1 ? ZValue.atom(String(components[1])) : ZValue.number(0)

            // Allocate global and store the initial value
            let globalAddress = memoryLayout.allocateGlobal(varName)
            state.addSymbol(varName, address: globalAddress, location: location)
            state.addConstant("\(varName)_INIT", value: varValue)
            return address

        case "END":
            // End of assembly marker
            return address

        default:
            throw AssemblyError.invalidInstruction(directive.name, location: location)
        }
    }

    /// Calculate encoded string length for memory allocation
    private func calculateEncodedStringLength(_ content: String) -> UInt32 {
        // Estimate encoded Z-string length
        // Each 16-bit word holds 3 Z-characters (5 bits each + 1 end bit)
        let chars = content.count
        let words = (chars + 2) / 3  // Round up to nearest word boundary
        return UInt32(words * 2)  // Each word is 2 bytes
    }

    private func processDirectiveSecondPass(_ directive: ZAPDirective, location: SourceLocation) throws {
        switch directive.name.uppercased() {
        case "OBJECT":
            if directive.arguments.count > 1 {
                // Object has properties
                guard let name = directive.arguments.first?.asAtom else { return }
                try memoryLayout.startObject(name, location: location)
            }

        case "ENDOBJECT":
            try memoryLayout.endObject(location: location)

        case "BYTE":
            // Process byte data directive
            var data = Data()
            for arg in directive.arguments {
                switch arg {
                case .number(let value):
                    data.append(UInt8(value & 0xFF))
                case .atom(let name):
                    // Resolve symbol to byte value
                    if let address = state.symbolTable[name] {
                        data.append(UInt8(address & 0xFF))
                    } else if let constant = state.constants[name] {
                        if let numValue = constant.asNumber {
                            data.append(UInt8(numValue & 0xFF))
                        } else {
                            throw AssemblyError.undefinedLabel(name, location: location)
                        }
                    } else {
                        throw AssemblyError.undefinedLabel(name, location: location)
                    }
                default:
                    throw AssemblyError.invalidOperand(instruction: "BYTE", operand: "unsupported value type", location: location)
                }
            }
            memoryLayout.addData(data)

        case "WORD":
            // Process word data directive
            var data = Data()
            for arg in directive.arguments {
                switch arg {
                case .number(let value):
                    let word = UInt16(value) & 0xFFFF
                    data.append(UInt8((word >> 8) & 0xFF))  // High byte first
                    data.append(UInt8(word & 0xFF))         // Low byte second
                case .atom(let name):
                    // Resolve symbol to word value
                    if let address = state.symbolTable[name] {
                        let word = UInt16(address) & 0xFFFF
                        data.append(UInt8((word >> 8) & 0xFF))
                        data.append(UInt8(word & 0xFF))
                    } else if let constant = state.constants[name] {
                        if let numValue = constant.asNumber {
                            let word = UInt16(numValue) & 0xFFFF
                            data.append(UInt8((word >> 8) & 0xFF))
                            data.append(UInt8(word & 0xFF))
                        } else {
                            throw AssemblyError.undefinedLabel(name, location: location)
                        }
                    } else {
                        throw AssemblyError.undefinedLabel(name, location: location)
                    }
                default:
                    throw AssemblyError.invalidOperand(instruction: "WORD", operand: "unsupported value type", location: location)
                }
            }
            memoryLayout.addData(data)

        case "STR":
            // Process string directive (alternative to STRING)
            guard let content = directive.arguments.first?.asString else {
                throw AssemblyError.invalidOperand(instruction: "STR", operand: "requires string content", location: location)
            }

            // Generate a unique string ID if not provided
            let stringId = directive.arguments.count > 1
                ? (directive.arguments[1].asAtom ?? "STR_\(memoryLayout.getStringCount())")
                : "STR_\(memoryLayout.getStringCount())"

            _ = memoryLayout.addString(stringId, content: content)

        case "GVAR":
            // Process enhanced global variable directive
            // This was mostly handled in first pass, but we may need to set initial values
            guard let nameAndValue = directive.arguments.first?.asAtom else {
                throw AssemblyError.invalidOperand(instruction: "GVAR", operand: "requires variable definition", location: location)
            }

            let components = nameAndValue.split(separator: "=", maxSplits: 1)
            let varName = String(components[0])

            if components.count > 1 {
                let valueStr = String(components[1])
                // Set initial value in global table
                if let address = state.symbolTable[varName] {
                    try memoryLayout.setGlobalInitialValue(varName, address: address, value: valueStr, symbolTable: state.symbolTable, location: location)
                }
            }

        default:
            // Most directives were handled in first pass
            break
        }
    }
}

// MARK: - Assembly State Management

/// Tracks the current state during assembly including symbols and constants
private class AssemblyState {
    /// Symbol table mapping names to addresses
    var symbolTable: [String: UInt32] = [:]

    /// Constant table mapping names to values
    var constants: [String: ZValue] = [:]

    /// Currently active function name (for local label resolution)
    var currentFunction: String?

    /// Currently active object name (for object property assignment)
    var currentObject: String?

    /// Add a symbol with its resolved address
    func addSymbol(_ name: String?, address: UInt32, location: SourceLocation) {
        guard let name = name else { return }
        symbolTable[name] = address
    }

    /// Add a constant value
    func addConstant(_ name: String, value: ZValue) {
        constants[name] = value
    }

    /// Resolve a symbol to its address
    func resolveSymbol(_ name: String, location: SourceLocation) throws -> UInt32 {
        if let address = symbolTable[name] {
            return address
        }
        throw AssemblyError.undefinedLabel(name, location: location)
    }
}

// MARK: - Assembly Data Structures

/// Represents a parsed ZAP assembly statement
public enum ZAPStatement {
    case directive(ZAPDirective, SourceLocation)
    case instruction(ZAPInstruction, SourceLocation)
    case objectProperty(ZAPObjectProperty, SourceLocation)
    case label(String, SourceLocation)
    case comment(String, SourceLocation)
}

/// Represents a ZAP object property assignment within an object block
public struct ZAPObjectProperty {
    public let name: String
    public let value: ZValue

    public init(name: String, value: ZValue) {
        self.name = name
        self.value = value
    }
}

/// Represents a ZAP assembler directive (.ZVERSION, .FUNCT, etc.)
public struct ZAPDirective {
    public let name: String
    public let arguments: [ZValue]

    public init(name: String, arguments: [ZValue] = []) {
        self.name = name
        self.arguments = arguments
    }
}

/// Represents a ZAP assembly instruction
/// Branch condition for Z-Machine instructions
public enum BranchCondition {
    case branchOnTrue    // `/label` - branch when condition is true
    case branchOnFalse   // `\label` - branch when condition is false
}

public struct ZAPInstruction {
    public let opcode: String
    public let operands: [ZValue]
    public let label: String?
    public let branchTarget: String?
    public let branchCondition: BranchCondition?
    public let resultTarget: String?

    public init(opcode: String, operands: [ZValue] = [], label: String? = nil, branchTarget: String? = nil, branchCondition: BranchCondition? = nil, resultTarget: String? = nil) {
        self.opcode = opcode
        self.operands = operands
        self.label = label
        self.branchTarget = branchTarget
        self.branchCondition = branchCondition
        self.resultTarget = resultTarget
    }
}